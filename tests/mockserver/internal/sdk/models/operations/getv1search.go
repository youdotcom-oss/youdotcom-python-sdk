// Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.

package operations

import (
	"errors"
	"fmt"
	"mockserver/internal/sdk/models/components"
	"mockserver/internal/sdk/utils"
	"time"
)

type FreshnessType string

const (
	FreshnessTypeFreshness FreshnessType = "Freshness"
	FreshnessTypeStr       FreshnessType = "str"
)

// Freshness - Specifies the freshness of the results to return.
type Freshness struct {
	Freshness *components.Freshness `queryParam:"inline"`
	Str       *string               `queryParam:"inline"`

	Type FreshnessType
}

func CreateFreshnessFreshness(freshness components.Freshness) Freshness {
	typ := FreshnessTypeFreshness

	return Freshness{
		Freshness: &freshness,
		Type:      typ,
	}
}

func CreateFreshnessStr(str string) Freshness {
	typ := FreshnessTypeStr

	return Freshness{
		Str:  &str,
		Type: typ,
	}
}

func (u *Freshness) UnmarshalJSON(data []byte) error {

	var freshness components.Freshness = components.Freshness("")
	if err := utils.UnmarshalJSON(data, &freshness, "", true, nil); err == nil {
		u.Freshness = &freshness
		u.Type = FreshnessTypeFreshness
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = FreshnessTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Freshness", string(data))
}

func (u Freshness) MarshalJSON() ([]byte, error) {
	if u.Freshness != nil {
		return utils.MarshalJSON(u.Freshness, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type Freshness: all fields are null")
}

type CountryType string

const (
	CountryTypeCountry CountryType = "Country"
	CountryTypeStr     CountryType = "str"
)

// Country - The country code that determines the geographical focus of the web results.
type Country struct {
	Country *components.Country `queryParam:"inline"`
	Str     *string             `queryParam:"inline"`

	Type CountryType
}

func CreateCountryCountry(country components.Country) Country {
	typ := CountryTypeCountry

	return Country{
		Country: &country,
		Type:    typ,
	}
}

func CreateCountryStr(str string) Country {
	typ := CountryTypeStr

	return Country{
		Str:  &str,
		Type: typ,
	}
}

func (u *Country) UnmarshalJSON(data []byte) error {

	var country components.Country = components.Country("")
	if err := utils.UnmarshalJSON(data, &country, "", true, nil); err == nil {
		u.Country = &country
		u.Type = CountryTypeCountry
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = CountryTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Country", string(data))
}

func (u Country) MarshalJSON() ([]byte, error) {
	if u.Country != nil {
		return utils.MarshalJSON(u.Country, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type Country: all fields are null")
}

type SafesearchType string

const (
	SafesearchTypeSafeSearch SafesearchType = "SafeSearch"
	SafesearchTypeStr        SafesearchType = "str"
)

// Safesearch - Configures the safesearch filter for content moderation. This allows you to decide whether to return NSFW content or not.
type Safesearch struct {
	SafeSearch *components.SafeSearch `queryParam:"inline"`
	Str        *string                `queryParam:"inline"`

	Type SafesearchType
}

func CreateSafesearchSafeSearch(safeSearch components.SafeSearch) Safesearch {
	typ := SafesearchTypeSafeSearch

	return Safesearch{
		SafeSearch: &safeSearch,
		Type:       typ,
	}
}

func CreateSafesearchStr(str string) Safesearch {
	typ := SafesearchTypeStr

	return Safesearch{
		Str:  &str,
		Type: typ,
	}
}

func (u *Safesearch) UnmarshalJSON(data []byte) error {

	var safeSearch components.SafeSearch = components.SafeSearch("")
	if err := utils.UnmarshalJSON(data, &safeSearch, "", true, nil); err == nil {
		u.SafeSearch = &safeSearch
		u.Type = SafesearchTypeSafeSearch
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = SafesearchTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Safesearch", string(data))
}

func (u Safesearch) MarshalJSON() ([]byte, error) {
	if u.SafeSearch != nil {
		return utils.MarshalJSON(u.SafeSearch, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type Safesearch: all fields are null")
}

type LivecrawlType string

const (
	LivecrawlTypeLiveCrawl LivecrawlType = "LiveCrawl"
	LivecrawlTypeStr       LivecrawlType = "str"
)

// Livecrawl - Indicates which section(s) of search results to livecrawl and return full page content.
type Livecrawl struct {
	LiveCrawl *components.LiveCrawl `queryParam:"inline"`
	Str       *string               `queryParam:"inline"`

	Type LivecrawlType
}

func CreateLivecrawlLiveCrawl(liveCrawl components.LiveCrawl) Livecrawl {
	typ := LivecrawlTypeLiveCrawl

	return Livecrawl{
		LiveCrawl: &liveCrawl,
		Type:      typ,
	}
}

func CreateLivecrawlStr(str string) Livecrawl {
	typ := LivecrawlTypeStr

	return Livecrawl{
		Str:  &str,
		Type: typ,
	}
}

func (u *Livecrawl) UnmarshalJSON(data []byte) error {

	var liveCrawl components.LiveCrawl = components.LiveCrawl("")
	if err := utils.UnmarshalJSON(data, &liveCrawl, "", true, nil); err == nil {
		u.LiveCrawl = &liveCrawl
		u.Type = LivecrawlTypeLiveCrawl
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = LivecrawlTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for Livecrawl", string(data))
}

func (u Livecrawl) MarshalJSON() ([]byte, error) {
	if u.LiveCrawl != nil {
		return utils.MarshalJSON(u.LiveCrawl, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type Livecrawl: all fields are null")
}

type LivecrawlFormatsType string

const (
	LivecrawlFormatsTypeLiveCrawlFormats LivecrawlFormatsType = "LiveCrawlFormats"
	LivecrawlFormatsTypeStr              LivecrawlFormatsType = "str"
)

// LivecrawlFormats - Indicates the format of the livecrawled content.
type LivecrawlFormats struct {
	LiveCrawlFormats *components.LiveCrawlFormats `queryParam:"inline"`
	Str              *string                      `queryParam:"inline"`

	Type LivecrawlFormatsType
}

func CreateLivecrawlFormatsLiveCrawlFormats(liveCrawlFormats components.LiveCrawlFormats) LivecrawlFormats {
	typ := LivecrawlFormatsTypeLiveCrawlFormats

	return LivecrawlFormats{
		LiveCrawlFormats: &liveCrawlFormats,
		Type:             typ,
	}
}

func CreateLivecrawlFormatsStr(str string) LivecrawlFormats {
	typ := LivecrawlFormatsTypeStr

	return LivecrawlFormats{
		Str:  &str,
		Type: typ,
	}
}

func (u *LivecrawlFormats) UnmarshalJSON(data []byte) error {

	var liveCrawlFormats components.LiveCrawlFormats = components.LiveCrawlFormats("")
	if err := utils.UnmarshalJSON(data, &liveCrawlFormats, "", true, nil); err == nil {
		u.LiveCrawlFormats = &liveCrawlFormats
		u.Type = LivecrawlFormatsTypeLiveCrawlFormats
		return nil
	}

	var str string = ""
	if err := utils.UnmarshalJSON(data, &str, "", true, nil); err == nil {
		u.Str = &str
		u.Type = LivecrawlFormatsTypeStr
		return nil
	}

	return fmt.Errorf("could not unmarshal `%s` into any supported union types for LivecrawlFormats", string(data))
}

func (u LivecrawlFormats) MarshalJSON() ([]byte, error) {
	if u.LiveCrawlFormats != nil {
		return utils.MarshalJSON(u.LiveCrawlFormats, "", true)
	}

	if u.Str != nil {
		return utils.MarshalJSON(u.Str, "", true)
	}

	return nil, errors.New("could not marshal union type LivecrawlFormats: all fields are null")
}

type GetV1SearchRequest struct {
	// The search query used to retrieve relevant results from the web. You can also include [search operators](#search-operators) to refine your search.
	Query string `default:"Your query" queryParam:"style=form,explode=true,name=query"`
	// Specifies the maximum number of search results to return per section (the sections are `web` and `news`. See the JSON response to visualize them).
	Count *int64 `queryParam:"style=form,explode=true,name=count"`
	// Specifies the freshness of the results to return.
	Freshness *Freshness `queryParam:"style=form,explode=true,name=freshness"`
	// Indicates the `offset` for pagination. The `offset` is calculated in multiples of `count`. For example, if `count = 5` and `offset = 1`, results 5–10 will be returned. Range `0 ≤ offset ≤ 9`.
	Offset *int64 `queryParam:"style=form,explode=true,name=offset"`
	// The country code that determines the geographical focus of the web results.
	Country *Country `queryParam:"style=form,explode=true,name=country"`
	// Configures the safesearch filter for content moderation. This allows you to decide whether to return NSFW content or not.
	Safesearch *Safesearch `queryParam:"style=form,explode=true,name=safesearch"`
	// Indicates which section(s) of search results to livecrawl and return full page content.
	Livecrawl *Livecrawl `queryParam:"style=form,explode=true,name=livecrawl"`
	// Indicates the format of the livecrawled content.
	LivecrawlFormats *LivecrawlFormats `queryParam:"style=form,explode=true,name=livecrawl_formats"`
}

func (g GetV1SearchRequest) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(g, "", false)
}

func (g *GetV1SearchRequest) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &g, "", false, []string{"query"}); err != nil {
		return err
	}
	return nil
}

func (o *GetV1SearchRequest) GetQuery() string {
	if o == nil {
		return ""
	}
	return o.Query
}

func (o *GetV1SearchRequest) GetCount() *int64 {
	if o == nil {
		return nil
	}
	return o.Count
}

func (o *GetV1SearchRequest) GetFreshness() *Freshness {
	if o == nil {
		return nil
	}
	return o.Freshness
}

func (o *GetV1SearchRequest) GetOffset() *int64 {
	if o == nil {
		return nil
	}
	return o.Offset
}

func (o *GetV1SearchRequest) GetCountry() *Country {
	if o == nil {
		return nil
	}
	return o.Country
}

func (o *GetV1SearchRequest) GetSafesearch() *Safesearch {
	if o == nil {
		return nil
	}
	return o.Safesearch
}

func (o *GetV1SearchRequest) GetLivecrawl() *Livecrawl {
	if o == nil {
		return nil
	}
	return o.Livecrawl
}

func (o *GetV1SearchRequest) GetLivecrawlFormats() *LivecrawlFormats {
	if o == nil {
		return nil
	}
	return o.LivecrawlFormats
}

type Web struct {
	// The URL of the specific search result.
	URL *string `json:"url,omitempty"`
	// The title or name of the search result.
	Title *string `json:"title,omitempty"`
	// A brief description of the content of the search result.
	Description *string `json:"description,omitempty"`
	// An array of text snippets from the search result, providing a preview of the content.
	Snippets []string `json:"snippets,omitempty"`
	// URL of the thumbnail.
	ThumbnailURL *string `json:"thumbnail_url,omitempty"`
	// The age of the search result.
	PageAge *time.Time `json:"page_age,omitempty"`
	// An array of authors of the search result.
	Authors []string `json:"authors,omitempty"`
	// The URL of the favicon of the search result's domain.
	FaviconURL *string `json:"favicon_url,omitempty"`
}

func (w Web) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(w, "", false)
}

func (w *Web) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &w, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *Web) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

func (o *Web) GetTitle() *string {
	if o == nil {
		return nil
	}
	return o.Title
}

func (o *Web) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *Web) GetSnippets() []string {
	if o == nil {
		return nil
	}
	return o.Snippets
}

func (o *Web) GetThumbnailURL() *string {
	if o == nil {
		return nil
	}
	return o.ThumbnailURL
}

func (o *Web) GetPageAge() *time.Time {
	if o == nil {
		return nil
	}
	return o.PageAge
}

func (o *Web) GetAuthors() []string {
	if o == nil {
		return nil
	}
	return o.Authors
}

func (o *Web) GetFaviconURL() *string {
	if o == nil {
		return nil
	}
	return o.FaviconURL
}

type News struct {
	// The title of the news result.
	Title *string `json:"title,omitempty"`
	// A brief description of the content of the news result.
	Description *string `json:"description,omitempty"`
	// UTC timestamp of the article's publication date.
	PageAge *time.Time `json:"page_age,omitempty"`
	// URL of the thumbnail.
	ThumbnailURL *string `json:"thumbnail_url,omitempty"`
	// The URL of the news result.
	URL *string `json:"url,omitempty"`
}

func (n News) MarshalJSON() ([]byte, error) {
	return utils.MarshalJSON(n, "", false)
}

func (n *News) UnmarshalJSON(data []byte) error {
	if err := utils.UnmarshalJSON(data, &n, "", false, nil); err != nil {
		return err
	}
	return nil
}

func (o *News) GetTitle() *string {
	if o == nil {
		return nil
	}
	return o.Title
}

func (o *News) GetDescription() *string {
	if o == nil {
		return nil
	}
	return o.Description
}

func (o *News) GetPageAge() *time.Time {
	if o == nil {
		return nil
	}
	return o.PageAge
}

func (o *News) GetThumbnailURL() *string {
	if o == nil {
		return nil
	}
	return o.ThumbnailURL
}

func (o *News) GetURL() *string {
	if o == nil {
		return nil
	}
	return o.URL
}

type Results struct {
	Web  []Web  `json:"web,omitempty"`
	News []News `json:"news,omitempty"`
}

func (o *Results) GetWeb() []Web {
	if o == nil {
		return nil
	}
	return o.Web
}

func (o *Results) GetNews() []News {
	if o == nil {
		return nil
	}
	return o.News
}

type Metadata struct {
	RequestUUID *string `json:"request_uuid,omitempty"`
	// Returns the search query used to retrieve the results.
	Query   *string  `json:"query,omitempty"`
	Latency *float64 `json:"latency,omitempty"`
}

func (o *Metadata) GetRequestUUID() *string {
	if o == nil {
		return nil
	}
	return o.RequestUUID
}

func (o *Metadata) GetQuery() *string {
	if o == nil {
		return nil
	}
	return o.Query
}

func (o *Metadata) GetLatency() *float64 {
	if o == nil {
		return nil
	}
	return o.Latency
}

// GetV1SearchResponseBody - A JSON object containing unified search results from web and news sources
type GetV1SearchResponseBody struct {
	Results  *Results  `json:"results,omitempty"`
	Metadata *Metadata `json:"metadata,omitempty"`
}

func (o *GetV1SearchResponseBody) GetResults() *Results {
	if o == nil {
		return nil
	}
	return o.Results
}

func (o *GetV1SearchResponseBody) GetMetadata() *Metadata {
	if o == nil {
		return nil
	}
	return o.Metadata
}

type GetV1SearchResponse struct {
	HTTPMeta components.HTTPMetadata `json:"-"`
	// A JSON object containing unified search results from web and news sources
	Object *GetV1SearchResponseBody
}

func (o *GetV1SearchResponse) GetHTTPMeta() components.HTTPMetadata {
	if o == nil {
		return components.HTTPMetadata{}
	}
	return o.HTTPMeta
}

func (o *GetV1SearchResponse) GetObject() *GetV1SearchResponseBody {
	if o == nil {
		return nil
	}
	return o.Object
}
