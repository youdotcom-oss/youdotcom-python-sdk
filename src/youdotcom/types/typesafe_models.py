"""
Type-safe models for Tools and SSE Events.

This module provides strongly-typed Pydantic models for You.com agent tools and SSE events.
These models enable IDE autocomplete, type checking, and runtime validation.

Note: This file is NOT generated by Speakeasy and should be maintained manually.
It provides enhanced type safety on top of the generated SDK models.

IMPORTANT: The tool type field values must match the discriminated union tags
defined in models/tool.py (lines 21-23):
"""

from __future__ import annotations
from enum import Enum
from typing import Any, List, Literal, Optional, Union
from pydantic import BaseModel


# ============================================================================
# Enums for type-safe configuration
# ============================================================================

class Trigger(str, Enum):
    """When to trigger a tool: 'intent' lets the agent decide, 'force' always triggers."""
    INTENT = "intent"
    FORCE = "force"

# ============================================================================
# Enums for Agents API
# ============================================================================

class AgentType(str, Enum):
    """Built-in agent types."""
    EXPRESS = "express"
    ADVANCED = "advanced"


class SearchEffort(str, Enum):
    """Search effort level for research: 'auto' lets agent decide"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    AUTO = "auto"

class Verbosity(str, Enum):
    """Response verbosity level"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"

# ============================================================================
# Enums for Search API (V1)
# ============================================================================

class Freshness(str, Enum):
    """Specifies the freshness of the results to return."""
    DAY = "day"
    WEEK = "week"
    MONTH = "month"
    YEAR = "year"

class Country(str, Enum):
    """The country code that determines the geographical focus of the web results."""
    AR = "AR"
    AU = "AU"
    AT = "AT"
    BE = "BE"
    BR = "BR"
    CA = "CA"
    CL = "CL"
    DK = "DK"
    FI = "FI"
    FR = "FR"
    DE = "DE"
    HK = "HK"
    IN = "IN"
    ID = "ID"
    IT = "IT"
    JP = "JP"
    KR = "KR"
    MY = "MY"
    MX = "MX"
    NL = "NL"
    NZ = "NZ"
    NO = "NO"
    CN = "CN"
    PL = "PL"
    PT = "PT"
    PH = "PH"
    RU = "RU"
    SA = "SA"
    ZA = "ZA"
    ES = "ES"
    SE = "SE"
    CH = "CH"
    TW = "TW"
    TR = "TR"
    GB = "GB"
    US = "US"

class SafeSearch(str, Enum):
    """Configures the safesearch filter for content moderation."""
    OFF = "off"
    MODERATE = "moderate"
    STRICT = "strict"

class LiveCrawl(str, Enum):
    """Indicates which section(s) of search results to livecrawl and return full page content."""
    WEB = "web"
    NEWS = "news"
    ALL = "all"

class LiveCrawlFormats(str, Enum):
    """Indicates the format of the livecrawled content."""
    HTML = "html"
    MARKDOWN = "markdown"

# ============================================================================
# Enums for Contents API (V1)
# ============================================================================

class Format(str, Enum):
    """The format of the content to be returned."""
    HTML = "html"
    MARKDOWN = "markdown"

# ============================================================================
# Tool Models (Discriminated Union)
# ============================================================================

class WebSearchTool(BaseModel):
    """
    Web search tool with optional intent-based triggering.
    
    Example:
        >>> tool = WebSearchTool(trigger=Trigger.INTENT)
        >>> # Let agent decide when to search
        
        >>> tool = WebSearchTool(trigger=Trigger.FORCE)
        >>> # Always perform search
    """
    type: Literal["web_search"] = "web_search"
    trigger: Trigger = Trigger.INTENT


class ComputeTool(BaseModel):
    """
    Mathematical computation tool.
    
    Example:
        >>> tool = ComputeTool(expression="2 + 2")
        >>> # Compute mathematical expressions
    """
    type: Literal["compute"] = "compute"
    expression: str


class ResearchTool(BaseModel):
    """
    Research tool for conducting research on a topic.
    
    Example:
        >>> tool = ResearchTool(topic="What is quantum computing?")
        >>> # Research a specific topic
    """
    type: Literal["research"] = "research"
    topic: str


# Union type for all tools (discriminated by 'type' field)
Tool = Union[WebSearchTool, ComputeTool, ResearchTool]


# ============================================================================
# SSE Event Models (Discriminated Union for Full Responses)
# ============================================================================

class WebSearchResult(BaseModel):
    """A single web search result."""
    url: str
    title: str
    description: Optional[str] = None
    age: Optional[str] = None


class WebSearchResultsFull(BaseModel):
    """Full web search results from SSE event."""
    type: Literal["web_search.results"] = "web_search.results"
    results: List[WebSearchResult]


class Source(BaseModel):
    """A source citation."""
    url: str
    title: str
    snippet: Optional[str] = None


class ChatAnswerFull(BaseModel):
    """Full chat answer from SSE event."""
    type: Literal["chat_node.answer"] = "chat_node.answer"
    text: str
    sources: Optional[List[Source]] = None


class ComputeResultsFull(BaseModel):
    """Full compute results from SSE event."""
    type: Literal["compute.results"] = "compute.results"
    result: str
    expression: str


class ResearchResultsFull(BaseModel):
    """Full research results from SSE event."""
    type: Literal["research.results"] = "research.results"
    report: str
    sources: Optional[List[Source]] = None


class GenericFull(BaseModel):
    """Generic full response for unknown or custom event types."""
    type: str
    
    class Config:
        extra = "allow"  # Allow additional fields


# Union type for all full responses (discriminated by 'type' field)
FullResponse = Union[
    WebSearchResultsFull,
    ChatAnswerFull,
    ComputeResultsFull,
    ResearchResultsFull,
    GenericFull,
]


# ============================================================================
# SSE Event Data Models
# ============================================================================

class SSEResponse(BaseModel):
    """SSE response containing event data."""
    type: Optional[str] = None
    output_index: Optional[int] = None
    delta: Optional[str] = None
    full: Optional[FullResponse] = None


class SSEEventData(BaseModel):
    """Data payload of an SSE event."""
    seq_id: Optional[int] = None
    type: Optional[str] = None
    response: Optional[SSEResponse] = None


class SSEEvent(BaseModel):
    """Server-Sent Event structure."""
    id: Optional[str] = None
    event: Optional[str] = None
    data: Optional[SSEEventData] = None


# ============================================================================
# Event Type Enums for Pattern Matching
# ============================================================================

class SSEEventType(str, Enum):
    """SSE event types for easier pattern matching."""
    RESPONSE_CREATED = "response.created"
    RESPONSE_STARTING = "response.starting"
    RESPONSE_OUTPUT_ITEM_ADDED = "response.output_item.added"
    RESPONSE_OUTPUT_TEXT_DELTA = "response.output_text.delta"
    RESPONSE_OUTPUT_CONTENT_FULL = "response.output_content.full"
    RESPONSE_OUTPUT_ITEM_DONE = "response.output_item.done"
    DONE = "done"


class OutputType(str, Enum):
    """Output types for pattern matching."""
    WEB_SEARCH_RESULTS = "web_search.results"
    CHAT_NODE_ANSWER = "chat_node.answer"
    COMPUTE_RESULTS = "compute.results"
    RESEARCH_RESULTS = "research.results"


# ============================================================================
# Helper Functions for Type-Safe Event Handling
# ============================================================================

def parse_sse_event(event: Any) -> SSEEvent:
    """
    Parse a raw SSE event into a type-safe SSEEvent model.
    
    Args:
        event: Raw event data from the event stream
        
    Returns:
        Parsed SSEEvent with proper typing
        
    Example:
        >>> for event in stream:
        ...     typed_event = parse_sse_event(event)
        ...     if typed_event.event == SSEEventType.RESPONSE_OUTPUT_TEXT_DELTA:
        ...         print(typed_event.data.response.delta, end="", flush=True)
    """
    if isinstance(event, SSEEvent):
        return event
    return SSEEvent.model_validate(event)


def is_text_delta(event: SSEEvent) -> bool:
    """Check if event is a text delta event."""
    return event.event == SSEEventType.RESPONSE_OUTPUT_TEXT_DELTA.value


def is_full_response(event: SSEEvent) -> bool:
    """Check if event contains a full response."""
    return bool(
        event.event == SSEEventType.RESPONSE_OUTPUT_CONTENT_FULL.value
        and event.data 
        and event.data.response 
        and event.data.response.full is not None
    )


def get_delta_text(event: SSEEvent) -> Optional[str]:
    """
    Extract delta text from event if present.
    
    Returns:
        Delta text string or None
    """
    if event.data and event.data.response:
        return event.data.response.delta
    return None


def get_full_response(event: SSEEvent) -> Optional[FullResponse]:
    """
    Extract full response from event if present.
    
    Returns:
        Typed FullResponse or None
    """
    if event.data and event.data.response:
        return event.data.response.full
    return None


def get_text_tokens(res: Any, print_tokens: bool = True) -> List[str]:
    """
    Extract text tokens from agent response output.
    
    Helper function to extract text from non-streaming agent responses.
    Handles the common pattern of iterating through res.output and extracting text.
    
    Args:
        res: The response object from agents.runs.create() with stream=False.
            Should be a PostV1AgentsRunsResponseBody with an output field.
        print_tokens: If True, print tokens as they are extracted. If False, only collect them.
    
    Returns:
        List of text strings extracted from the output.
    
    Example:
        >>> from youdotcom import You
        >>> from youdotcom.models import PostV1AgentsRunsRequest
        >>> from youdotcom.types.typesafe_models import AgentType, get_text_tokens
        >>> 
        >>> res = you.agents.runs.create(
        ...     request=PostV1AgentsRunsRequest(
        ...         agent=AgentType.EXPRESS,
        ...         input="Hello",
        ...         stream=False,
        ...     )
        ... )
        >>> tokens = get_text_tokens(res, print_tokens=True)
    """
    tokens = []
    if hasattr(res, 'output') and res.output:
        for output in res.output:
            if hasattr(output, 'text') and output.text:
                tokens.append(output.text)
                if print_tokens:
                    print(output.text)
    return tokens


def print_search(search_response: Any) -> None:
    """
    Print search results from search API response.
    
    Helper function to extract and print search results from search.unified() responses.
    Prints web results and news results with their titles, URLs, descriptions, etc.
    
    Args:
        search_response: The response from search.unified(), which is a GetV1SearchResponse
            with a results field containing web and news results.
    
    Example:
        >>> from youdotcom import You
        >>> from youdotcom.types.typesafe_models import print_search
        >>> 
        >>> res = you.search.unified(query="python programming")
        >>> print_search(res)
    """
    if not hasattr(search_response, 'results') or not search_response.results:
        return
    
    results = search_response.results
    
    # Print web results
    if hasattr(results, 'web') and results.web:
        print("Web Results:")
        print("=" * 50)
        for i, web_result in enumerate(results.web, 1):
            if hasattr(web_result, 'title') and web_result.title:
                print(f"{i}. {web_result.title}")
            if hasattr(web_result, 'url') and web_result.url:
                print(f"   URL: {web_result.url}")
            if hasattr(web_result, 'description') and web_result.description:
                print(f"   Description: {web_result.description}")
            if hasattr(web_result, 'snippets') and web_result.snippets:
                for snippet in web_result.snippets[:2]:  # Show first 2 snippets
                    print(f"   - {snippet}")
            print()
    
    # Print news results
    if hasattr(results, 'news') and results.news:
        print("News Results:")
        print("=" * 50)
        for i, news_result in enumerate(results.news, 1):
            if hasattr(news_result, 'title') and news_result.title:
                print(f"{i}. {news_result.title}")
            if hasattr(news_result, 'url') and news_result.url:
                print(f"   URL: {news_result.url}")
            if hasattr(news_result, 'description') and news_result.description:
                print(f"   Description: {news_result.description}")
            print()
    
    # Print metadata if available
    if hasattr(search_response, 'metadata') and search_response.metadata:
        metadata = search_response.metadata
        if hasattr(metadata, 'query') and metadata.query:
            print(f"Query: {metadata.query}")
        if hasattr(metadata, 'latency') and metadata.latency:
            print(f"Latency: {metadata.latency}s")


def print_contents(contents: Any) -> None:
    """
    Print content from contents API response.
    
    Helper function to extract and print content from contents.generate() responses.
    Prints title, URL, and content (HTML or Markdown) for each content item.
    
    Args:
        contents: The response from contents.generate(), which is a list of 
            PostV1ContentsResponse objects.
    
    Example:
        >>> from youdotcom import You
        >>> from youdotcom.models import Format
        >>> from youdotcom.types.typesafe_models import print_contents
        >>> 
        >>> res = you.contents.generate(
        ...     urls=["https://www.you.com"],
        ...     format_=Format.MARKDOWN,
        ... )
        >>> print_contents(res)
    """
    if not isinstance(contents, list):
        return
    
    for content in contents:
        if hasattr(content, 'title') and content.title:
            print(f"Title: {content.title}")
        if hasattr(content, 'url') and content.url:
            print(f"URL: {content.url}")
        if hasattr(content, 'markdown') and content.markdown:
            print(f"Markdown:\n{content.markdown}")
        elif hasattr(content, 'html') and content.html:
            print(f"HTML:\n{content.html}")
        print()  # Empty line between items


def stream_text_tokens(res: Any, print_deltas: bool = True) -> str:
    """
    Stream text tokens from an SSE event stream and optionally print them.
    
    This helper function handles the common pattern of iterating through SSE events,
    collecting text deltas, and optionally printing them as they arrive.
    
    Args:
        res: The response object from agents.runs.create() with stream=True.
            Should be a PostV1AgentsRunsResponse that supports context manager protocol.
        print_deltas: If True, print deltas as they arrive. If False, only collect them.
    
    Returns:
        The complete text collected from all delta events.
    
    Example:
        >>> from youdotcom import You
        >>> from youdotcom.models import PostV1AgentsRunsRequest
        >>> from youdotcom.types.typesafe_models import AgentType, stream_text_tokens
        >>> 
        >>> res = you.agents.runs.create(
        ...     request=PostV1AgentsRunsRequest(
        ...         agent=AgentType.EXPRESS,
        ...         input="Hello",
        ...         stream=True,
        ...     )
        ... )
        >>> text = stream_text_tokens(res, print_deltas=True)
        >>> print(f"\\nComplete text: {text}")
    """
    collected_text = ""
    
    with res as event_stream:
        for event in event_stream:
            if event.response:
                response = event.response
                if response.delta:
                    if print_deltas:
                        print(response.delta, end="", flush=True)
                    collected_text += response.delta
                if response.full:
                    if print_deltas:
                        print("\n")
    
    return collected_text


